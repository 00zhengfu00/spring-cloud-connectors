:github-tag: master
:github-repo: spring-cloud/spring-cloud-connectors
:github-raw: http://raw.github.com/{github-repo}/{github-tag}
:github-code: http://github.com/{github-repo}/tree/{github-tag}
:toc:
:toclevels: 3

= Spring Cloud Spring Service Connector

The Spring Service Connector is part of the <<spring-cloud-connectors.adoc#,Spring Cloud Connectors>> project.

This library provides `ServiceConnectorCreator` implementations for `javax.sql.DataSource` and various link:http://projects.spring.io/spring-data/[Spring Data] connector factories. It also provides Java configuration and XML namespace support for connecting to cloud services, accessing cloud services, and accessing application properties.

== The Java Configuration

Typical use of the Java configuration involves extending the `AbstractCloudConfig` class and creating beans for services by annotating methods with the `@Bean` annotation. (If you are migrating an application that uses link:https://spring.io/blog/2011/11/04/using-cloud-foundry-services-with-spring-part-2-auto-reconfiguration/[auto-reconfiguration], you might first try the <<_scanning_for_services,service-scanning approach>> until you need more explicit control.) The Spring Service Connector Java configuration also offers a way to expose application and service properties in case you want lower-level access when creating your own service connectors (or for debugging purposes, etc.).  

=== Creating Service Beans

The configuration shown in the following example creates a `DataSource` bean that connects to the only relational database service bound to the application (it will fail if there is no such unique service).  It also creates a `MongoDbFactory` bean, which again connects to the only MongoDB service bound to the application. (For ways to connect to other services, see the link:http://docs.spring.io/autorepo/docs/spring-cloud/current/api/org/springframework/cloud/config/java/AbstractCloudConfig.html[Javadoc for `AbstractCloudConfig`].)

[source,java]
----
class CloudConfig extends AbstractCloudConfig {
    @Bean
        public DataSource inventoryDataSource() {
            return connectionFactory().dataSource();
        }
    
    @Bean
    public MongoDbFactory documentMongoDbFactory() {
        return connectionFactory().mongoDbFactory();
    }
    
    // (More beans to obtain service connectors)
}
----

You can specify a bean name by providing a value in the `@Bean` annotation.

[source,java]
----
@Bean("inventory-service")
----

Otherwise, bean names will match the method names. (This works in the same way as does Spring's Java configuration.)
    
If you have more than one service of a type bound to the application or want explicit control over the services to which a bean is bound, you can pass the service names to methods such as `dataSource()` and `mongoDbFactory()`.
    
[source,java]
----
class CloudConfig extends AbstractCloudConfig {
    @Bean
    public DataSource inventoryDataSource() {
        return connectionFactory().dataSource("inventory-db-service");
    }

    @Bean
    public MongoDbFactory documentMongoDbFactory() {
        return connectionFactory().mongoDbFactory("document-service");
    }

    // (More beans to obtain service connectors)
}
----
 
Methods such as `dataSource()` come in additional overloaded variants that let you specify configuration options (such as pooling parameters). See the relevant Javadocs for more information.

=== Connecting to Generic Services

The Java configuration supports access to generic services (services which don't have a directly mapped method; this is typical for a newly-introduced service or when connecting to a private service in a private PaaS) through the `service()` method. It follows the same pattern as `dataSource()` etc., except that it allows you to supply the connector type as an additional parameter.

=== Scanning for Services

You can scan for each bound service using the `@ServiceScan` annotation. (This is conceptually similar to Spring's `@ComponentScan` annotation.)

[source,java]
----
@Configuration
@ServiceScan
class CloudConfig {
}
----
    
In the above example, the configuration will create one bean of the appropriate type (such as a `DataSource` in the case of a relational database service). Each bean will have an `id` matching the corresponding service name.

You can inject such beans using autowiring.

[source,java]
----
@Autowired DataSource inventoryDb;
----

If the application is bound to more than one service of a given type, you can specify one by using the `@Qualifier` annotation and providing it with the name of the appropriate service.

[source,java]
----
@Autowired @Qualifier("inventory-db") DataSource inventoryDb;
@Autowired @Qualifier("shipping-db") DataSource shippingDb;
----

=== Accessing Service Properties

You can expose raw properties for all services and for the application through a bean.

[source,java]
----
class CloudPropertiesConfig extends AbstractCloudConfig {
    @Bean
    public Properties cloudProperties() {
        return properties();
    }
}
----

== The `<cloud>` Namespace

=== Setting Up

The `<cloud>` namespace offers a simple way for a Spring application to connect to cloud services.

To use this namespace, add a declaration for it.

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:cloud="http://www.springframework.org/schema/cloud"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/cloud http://www.springframework.org/schema/cloud/spring-cloud.xsd">

<!-- <cloud> namespace usage here -->
----

=== Creating Service Beans

A namespace element which creates a service bean conforms to the following pattern (in this example, the bean is for a relational database service).

[source,xml]
----
<cloud:data-source id="inventory-db" service-name="inventory-db-service">
    <cloud:connection properties="sessionVariables=sql_mode='ANSI';characterEncoding=UTF-8"/>
    <cloud:pool pool-size="20" max-wait-time="200"/>
</cloud>
----

The above example creates a `javax.sql.DataSource` bean with the id `inventory-db`. The bean is bound to the `inventory-db-service` and is configured with the `connection` and `pool` properties specified in the nested `<cloud:connection>` and `<cloud:pool>` elements.

If no `id` attribute is specified, the `id` is set to the service name. If no `service-name` is specified, the bean is bound to the only service in the corresponding category (in this case, a relational database). If no unique service is found, a runtime exception will be thrown.

Other namespace elements which create service connectors include:

[source,xml]
----
<cloud:mongo-db-factory/>
<cloud:redis-connection-factory/>
<cloud:rabbit-connection-factory/>
----

=== Connecting to Generic Services

Spring Service Connector also supports a generic `<cloud:service>` namespace for connecting to a service with no directly-mapped element (this is typical for a newly-introduced service or when connecting to a private service in a private PaaS). You must specify either the `connector-type` attribute (for locating a unique service by type) or the `service-name` attribute.

[source,xml]
----
 <cloud:service id="email" service-name="email-service" connector-type="com.something.EmailConnectory" />
----

=== Scanning for Services

Besides these elements (which create only one bean per element), Spring Service Connector provides a `<cloud:service-scan>` element, in the same spirit as the `<context:component-scan>` element. It scans for all services bound to the application and creates a bean for each service. Each bean has an `id` matching the service name; this means that you can use the `@Qualifier` annotation along with `@Autowired` when there is more than one bean of the same type.

=== Accessing Service Properties

Lastly, Spring Service Connector provides a `<cloud:properties>` element, which exposes properties for the application and for services.

